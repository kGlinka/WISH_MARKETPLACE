# Provider Bidding System Documentation

## Overview

The Provider Bidding System enables service providers to discover available wishes posted by customers and submit competitive bids. The system features real-time updates using Firebase Firestore streams, comprehensive bid management, and a user-friendly interface.

## Architecture

### Data Flow

```
Customer Creates Wish (Public)
    ↓
Provider Browses Available Wishes
    ↓
Provider Submits Bid
    ↓
Real-time Bid Updates (Firestore Streams)
    ↓
Customer Views All Bids
    ↓
Customer Accepts Bid
    ↓
Wish Status → In Progress
```

### Key Components

1. **Data Layer** (`features/bids/data/`)
   - `BidService`: Firestore operations for bids
   - `BidRepository`: Error handling and data mapping

2. **Presentation Layer** (`features/bids/presentation/`)
   - **Pages**:
     - `AvailableWishesPage`: Browse public wishes
     - `BidSubmissionPage`: Submit bids on wishes
     - `MyBidsPage`: View provider's bid history
   - **Widgets**:
     - `WishBidCard`: Display wish with bid info
     - `BidCard`: Individual bid display
     - `BidListWidget`: List of bids on a wish
     - `WishBidsSection`: Bids section for wish owners
   - **Providers**: Riverpod state management

## Features

### 1. Real-Time Updates

The system uses Firestore streams for live bid updates:

```dart
// Stream all bids for a wish
final bidsAsync = ref.watch(wishBidsStreamProvider(wishId));

// Stream highest bid
final highestBidAsync = ref.watch(highestBidStreamProvider(wishId));

// Stream provider's bids
final myBidsAsync = ref.watch(providerBidsStreamProvider);
```

**Benefits**:
- Instant notification when new bids are placed
- Live ranking updates
- No manual refresh needed
- Reduced server load with efficient queries

### 2. Bid Submission with Validation

Providers can submit bids with the following validations:
- Cannot bid on own wishes
- Amount must be positive
- Optional message (max 500 characters)
- Prevents duplicate bids

```dart
final bid = BidModel(
  id: '', // Generated by Firestore
  listingId: wishId,
  bidderId: userId,
  amount: amountInCents,
  status: BidStatus.active,
  message: messageText,
  createdAt: DateTime.now(),
);
```

### 3. Bid Management

**Provider Actions**:
- View all placed bids
- Filter by status (Active, Winning, Won, Lost, Cancelled)
- Withdraw active bids with reason
- Track bid history

**Customer Actions**:
- View all bids on their wishes
- Accept highest bid
- View bid details and provider messages

### 4. Bid Statuses

```dart
enum BidStatus {
  active,    // Bid is live and competing
  outbid,    // Another bid is higher
  winning,   // Currently highest bid
  won,       // Bid was accepted by customer
  lost,      // Another bid was accepted
  cancelled, // Provider withdrew bid
  expired,   // Wish deadline passed
}
```

### 5. Atomic Operations

The system uses Firestore transactions to ensure data consistency:

```dart
// Creating a bid
await _firestore.runTransaction((transaction) async {
  // Verify wish exists
  // Create bid document
  // Increment wish bid count
  // All succeed or all fail
});

// Accepting a bid
await _firestore.runTransaction((transaction) async {
  // Mark winning bid as won
  // Mark other bids as lost
  // Update wish status
});
```

## Database Structure

### Firestore Collections

```
wishes/{wishId}/
  - title, description, category, status, etc.
  - bidCount: number

  bids/{bidId}/
    - id: string
    - wishId: string
    - bidderId: string (provider)
    - amount: number (cents)
    - status: BidStatus
    - message: string?
    - createdAt: timestamp
    - updatedAt: timestamp?
    - cancelledAt: timestamp?
    - cancellationReason: string?
```

### Security Rules

```javascript
match /wishes/{wishId} {
  allow read: if isAuthenticated();
  allow create: if isAuthenticated();
  allow update: if isOwner(resource.data.userId) ||
                   canUpdateBidCount();

  match /bids/{bidId} {
    allow read: if isAuthenticated();
    allow create: if isAuthenticated();
    allow update: if isOwner(resource.data.bidderId) ||
                     isWishOwner();
    allow delete: if isOwner(resource.data.bidderId);
  }
}
```

## State Management

### Providers (Riverpod)

**Service Providers**:
```dart
bidServiceProvider        // BidService instance
bidRepositoryProvider     // BidRepository instance
```

**Stream Providers** (Real-time):
```dart
wishBidsStreamProvider(wishId)              // All bids for a wish
wishActiveBidsStreamProvider(wishId)        // Active bids only
highestBidStreamProvider(wishId)            // Current highest bid
providerBidsStreamProvider                  // Provider's all bids
providerActiveBidsStreamProvider            // Provider's active bids
filteredProviderBidsStreamProvider          // Filtered by status
```

**State Providers**:
```dart
selectedBidFilterProvider   // Current filter selection
bidFormProvider            // Form state (loading, error, success)
```

**Future Providers**:
```dart
hasProviderBidProvider(wishId)      // Check if provider bid exists
providerBidOnWishProvider(wishId)   // Get provider's bid on wish
```

## User Interface

### Available Wishes Page

**Features**:
- Search bar for filtering wishes
- Category and priority filters
- Real-time wish list with bid counts
- Navigate to bid submission

**Navigation**:
```dart
context.push('/wishes/${wishId}/bid');
```

### Bid Submission Page

**Features**:
- Wish details display
- Current highest bid indicator
- Bid amount input with validation
- Optional message field
- All bids list with rankings
- Prevention of duplicate bids

**Form Validation**:
- Required: Bid amount > 0
- Optional: Message (max 500 chars)
- Block: Own wish bidding
- Check: Existing bid detection

### My Bids Page

**Features**:
- Filter chips (All, Active, Winning, Won, Lost, Cancelled)
- Real-time bid status updates
- Withdrawal capability
- Navigation to wish details
- Empty states with helpful messages

## API Reference

### BidService Methods

```dart
// Create bid
Future<String> createBid({
  required String wishId,
  required BidModel bid,
})

// Update bid
Future<void> updateBid({
  required String wishId,
  required String bidId,
  required Map<String, dynamic> updates,
})

// Cancel/withdraw bid
Future<void> cancelBid({
  required String wishId,
  required String bidId,
  String? cancellationReason,
})

// Get single bid
Future<BidModel?> getBid({
  required String wishId,
  required String bidId,
})

// Stream bids for wish
Stream<List<BidModel>> streamBidsForWish({
  required String wishId,
  BidStatus? status,
})

// Stream provider bids
Stream<List<BidModel>> streamProviderBids({
  required String providerId,
  BidStatus? status,
})

// Get highest bid
Future<BidModel?> getHighestBid({
  required String wishId,
})

// Accept bid (wish owner)
Future<void> acceptBid({
  required String wishId,
  required String bidId,
})

// Check if provider has bid
Future<bool> hasProviderBidOnWish({
  required String wishId,
  required String providerId,
})
```

### BidRepository Methods

All methods return `Either<Failure, T>` for error handling:

```dart
// Same methods as BidService but wrapped with error handling
Future<Either<Failure, String>> createBid(...)
Future<Either<Failure, void>> updateBid(...)
Future<Either<Failure, void>> cancelBid(...)
Future<Either<Failure, BidModel?>> getBid(...)
// ... etc
```

## Race Condition Handling

### 1. Optimistic Locking

Firestore automatically handles concurrent updates using document versions.

### 2. Transactions

Critical operations use transactions:

```dart
// Bid creation with atomic bid count update
await _firestore.runTransaction((transaction) async {
  // Get wish to verify it exists
  final wishDoc = await transaction.get(wishRef);
  if (!wishDoc.exists) throw Exception('Wish not found');

  // Create bid
  transaction.set(bidRef, bidData);

  // Update wish bid count
  transaction.update(wishRef, {
    'bidCount': FieldValue.increment(1),
  });
});
```

### 3. Duplicate Bid Prevention

```dart
// Check before allowing bid submission
Future<bool> hasProviderBidOnWish({
  required String wishId,
  required String providerId,
}) async {
  final snapshot = await _firestore
      .collection('wishes')
      .doc(wishId)
      .collection('bids')
      .where('bidderId', isEqualTo: providerId)
      .where('status', whereIn: ['active', 'winning'])
      .limit(1)
      .get();

  return snapshot.docs.isNotEmpty;
}
```

## Error Handling

### Service Layer
```dart
try {
  // Firestore operation
} on FirestoreException catch (e) {
  throw FirestoreException(message: e.message);
} catch (e) {
  throw FirestoreException(message: 'Failed: ${e.toString()}');
}
```

### Repository Layer
```dart
try {
  final result = await _service.operation();
  return Right(result);
} on FirestoreException catch (e) {
  return Left(FirestoreFailure(message: e.message));
} catch (e) {
  return Left(UnknownFailure(message: e.toString()));
}
```

### UI Layer
```dart
bidsAsync.when(
  data: (bids) => BidsList(bids),
  loading: () => CircularProgressIndicator(),
  error: (error, stack) => ErrorWidget(error),
)
```

## Performance Optimizations

### 1. Indexed Queries

Composite indexes are defined in `firestore.indexes.json`:
- `bidderId + status + createdAt` (DESC)
- `status + amount` (DESC)

### 2. Stream Efficiency

Streams are auto-disposed when no longer needed:
```dart
final bidsAsync = ref.watch(
  wishBidsStreamProvider.autoDispose.family(wishId)
);
```

### 3. Pagination

For large bid lists, implement pagination:
```dart
query
  .orderBy('amount', descending: true)
  .limit(20)
  .startAfter(lastDocument);
```

## Testing

### Unit Tests

```dart
test('createBid increments wish bid count', () async {
  final bid = BidModel(...);
  await bidService.createBid(wishId: wishId, bid: bid);

  final wish = await getWish(wishId);
  expect(wish.bidCount, equals(1));
});
```

### Integration Tests

```dart
testWidgets('provider can submit bid', (tester) async {
  await tester.pumpWidget(MyApp());
  await tester.tap(find.byType(SubmitBidButton));
  await tester.pumpAndSettle();

  expect(find.text('Bid submitted successfully'), findsOneWidget);
});
```

## Future Enhancements

1. **Auto-bidding**: Allow providers to set max bid amounts
2. **Bid notifications**: Push notifications for bid status changes
3. **Bid analytics**: Track conversion rates and success metrics
4. **Bid history**: Detailed audit trail with all changes
5. **Bid escrow**: Integrate payment holds when bid accepted
6. **Bid messaging**: Direct chat between provider and customer
7. **Bid ratings**: Rate bid quality and provider reliability
8. **Smart bidding**: ML-powered bid suggestions

## Troubleshooting

### Common Issues

**Issue**: Bids not updating in real-time
- **Solution**: Check Firestore rules, verify stream provider setup

**Issue**: Duplicate bid prevention not working
- **Solution**: Ensure composite index exists for `bidderId + status`

**Issue**: Transaction timeout
- **Solution**: Reduce transaction complexity, use batch writes

**Issue**: Permission denied
- **Solution**: Verify authentication state and Firestore rules

## Routes

```dart
// Available wishes for bidding
/available-wishes

// Bid submission
/wishes/{wishId}/bid

// Provider's bids
/my-bids
/provider-bids
```

## Files Created

### Data Layer
- `lib/features/bids/data/services/bid_service.dart`
- `lib/features/bids/data/repositories/bid_repository.dart`

### Presentation Layer
- `lib/features/bids/presentation/providers/bid_providers.dart`
- `lib/features/bids/presentation/pages/available_wishes_page.dart`
- `lib/features/bids/presentation/pages/bid_submission_page.dart`
- `lib/features/bids/presentation/pages/my_bids_page.dart`
- `lib/features/bids/presentation/widgets/wish_bid_card.dart`
- `lib/features/bids/presentation/widgets/bid_card.dart`
- `lib/features/bids/presentation/widgets/bid_list_widget.dart`
- `lib/features/bids/presentation/widgets/wish_bids_section.dart`

### Configuration
- Updated `lib/core/routing/app_router.dart`
- Updated `lib/core/constants/app_constants.dart`
- Updated `firestore.indexes.json`

## Conclusion

The Provider Bidding System provides a robust, scalable solution for marketplace bidding with:
- Real-time updates using Firestore streams
- Atomic operations for data consistency
- Comprehensive error handling
- User-friendly interface
- Race condition prevention
- Secure access controls

For questions or issues, refer to the main project documentation or contact the development team.
